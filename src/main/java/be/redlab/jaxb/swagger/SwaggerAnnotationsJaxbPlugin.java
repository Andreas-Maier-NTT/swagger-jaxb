/*
 * Copyright 2013 Balder Van Camp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package be.redlab.jaxb.swagger;

import java.util.Collection;
import java.util.Map;
import java.util.Map.Entry;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlTransient;

import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;

import com.sun.codemodel.JAnnotationUse;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JFieldVar;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.tools.xjc.Options;
import com.sun.tools.xjc.Plugin;
import com.sun.tools.xjc.outline.ClassOutline;
import com.sun.tools.xjc.outline.Outline;
import com.wordnik.swagger.annotations.ApiClass;
import com.wordnik.swagger.annotations.ApiProperty;

/**
 * The SwaggerAnnotationsJaxbPlugin adds Swaggers {@link ApiClass} and {@link ApiProperty} to JAXB Generated classes.
 * Currently only working with Field Accessor annotations.
 *
 *
 * @author redlab
 * @param <a>
 *
 */
public class SwaggerAnnotationsJaxbPlugin extends Plugin {
	private static final String DATA_TYPE = "dataType";
	private static final String DESCRIPTION_CLASS = " description generated by jaxb-swagger, hence no class description yet.";
	private static final String WARNING_SKIPPING = "Skipping %s as it is not an implementation or class";
	private static final String DESCRIPTION = "description";
	private static final String IS = "is";
	private static final String VALUE = "value";
	private static final String GET = "get";
	private static final String SWAGGERIFY = "swaggerify";
	private static final String USAGE = "Add this plugin to the JAXB classes generator classpath and provide the argument '-swaggerify'.";

	/**
	 * The optio name to activate swagger annotations.
	 *
	 * @return swaggerify
	 */
	@Override
	public String getOptionName() {
		return SWAGGERIFY;

	}

	/**
	 * A usage description
	 */
	@Override
	public String getUsage() {
		return USAGE;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.sun.tools.xjc.Plugin#run(com.sun.tools.xjc.outline.Outline, com.sun.tools.xjc.Options,
	 * org.xml.sax.ErrorHandler)
	 *
	 * Api Annotations Info
	 * String value() default "";
	 * String allowableValues() default "";endIndex
	 * String access() default "";
	 * String notes() default "";
	 * String dataType() default "";
	 * boolean required() default false;
	 */
	/**
	 * The run method called by XJC.
	 */
	@Override
	public boolean run(final Outline outline, final Options opt, final ErrorHandler errorHandler) throws SAXException {
		Collection<? extends ClassOutline> classes = outline.getClasses();
		for (ClassOutline o : classes) {
			JDefinedClass implClass = o.implClass;
			if (null != implClass && implClass.isClass() && !implClass.isAbstract() && !implClass.isInterface()
					&& !implClass.isAnnotationTypeDeclaration()) {
				Collection<JAnnotationUse> annotations = implClass.annotations();
				if (!annotations.isEmpty()) {
					XmlAccessType access;
					access = XJCHelper.getAccessType(annotations);
					if (null != access) {
						addClassAnnotation(o);
						processClass(implClass, access);
					}
				}
			} else {
				errorHandler.warning(new SAXParseException(String.format(WARNING_SKIPPING, o), null));
			}
		}
		return true;
	}

	/**
	 * @param implClass
	 * @param access
	 */
	private void processClass(final JDefinedClass implClass, final XmlAccessType access) {
		Collection<JMethod> methods = implClass.methods();
		Map<String, JFieldVar> fields = implClass.fields();
		switch (access) {
		case PUBLIC_MEMBER:
			for (JMethod jm : methods) {
				int mods = jm.mods().getValue();
				if (validMods(mods) && null == XJCHelper.getAnnotation(jm.annotations(), XmlTransient.class)
						&& null == XJCHelper.getAnnotation(jm.annotations(), ApiProperty.class)) {
					JAnnotationUse annotation = XJCHelper.getAnnotation(jm.annotations(), XmlElement.class);
					addMethodAnnotation(implClass, jm, isRequiredByAnnotation(annotation), null);
				}
			}
			break;
		case FIELD:
			for (Entry<String, JFieldVar> e : fields.entrySet()) {
				int mods = e.getValue().mods().getValue();
				if (validFieldMods(mods) && null == XJCHelper.getAnnotation(e.getValue().annotations(), XmlTransient.class)) {
					addMethodAnnotationForField(implClass, e.getValue());
				}
			}
			for (JMethod jm : methods) {
				int mods = jm.mods().getValue();
				JAnnotationUse annotation = XJCHelper.getAnnotation(jm.annotations(), XmlElement.class);
				if (validMods(mods) && null != annotation) {
					addMethodAnnotation(implClass, jm, isRequiredByAnnotation(annotation), null);
				}
			}
			break;
		case PROPERTY:
			for (JMethod jm : methods) {
				int mods = jm.mods().getValue();
				if (validMods(mods) && null == XJCHelper.getAnnotation(jm.annotations(), XmlTransient.class)) {
					JAnnotationUse annotation = XJCHelper.getAnnotation(jm.annotations(), XmlElement.class);
					addMethodAnnotation(implClass, jm, isRequiredByAnnotation(annotation), null);
				}
			}
			break;
		case NONE:
			break;
		}

	}

	/**
	 * @param mods
	 * @return
	 */
	private boolean validFieldMods(final int mods) {
		if ((mods & JMod.FINAL) != 0 || (mods & JMod.STATIC) != 0
				|| (mods & JMod.ABSTRACT) != 0 || (mods & JMod.NATIVE) != 0 || (mods & JMod.TRANSIENT) != 0 || (mods & JMod.VOLATILE) != 0)
			return false;
		return true;

	}

	/**
	 * @param implClass
	 * @param jFieldVar
	 */
	private void addMethodAnnotationForField(final JDefinedClass implClass, final JFieldVar jFieldVar) {
		JMethod jm = getCorrespondingMethod(implClass, jFieldVar.name());
		if (null != jm) {
			addMethodAnnotation(implClass, jm, isRequired(jFieldVar), getDefault(jFieldVar));
		}
	}

	/**
	 * @param jFieldVar
	 * @return
	 */
	private String getDefault(final JFieldVar jFieldVar) {
		JAnnotationUse annotation = XJCHelper.getAnnotation(jFieldVar.annotations(), XmlElement.class);
		if (null != annotation) {
			return XJCHelper.getStringValueFromAnnotationMember(annotation, "defaultValue");
		}
		return null;
	}

	/**
	 * @param jFieldVar
	 * @return
	 */
	private boolean isRequired(final JFieldVar jFieldVar) {
		return jFieldVar.type().isPrimitive() || isRequiredByAnnotation(XJCHelper.getAnnotation(jFieldVar.annotations(), XmlElement.class));
	}

	/**
	 * @param annotation
	 * @return
	 */
	private boolean isRequiredByAnnotation(final JAnnotationUse annotation) {
		return null != annotation && "true".equalsIgnoreCase(XJCHelper.getStringValueFromAnnotationMember(annotation, "required"));
	}

	/**
	 * @param implClass
	 * @param key
	 * @return
	 */
	private JMethod getCorrespondingMethod(final JDefinedClass implClass, final String key) {
		StringBuilder b = new StringBuilder(key.substring(0, 1).toUpperCase());
		if (key.length() > 1) {
			b.append(key.substring(1));
		}
		String get = "get" + b.toString();
		String is = "is" + b.toString();
		for (JMethod m : implClass.methods()) {
			if (get.equals(m.name()) || is.equals(m.name())) {
				return m;
			}
		}
		return null;
	}

	/**
	 * @param jm
	 * @return
	 */
	private boolean validMods(final int mods) {
		if (((mods & JMod.PROTECTED) != 0 || (mods & JMod.PRIVATE) != 0 || (mods & JMod.FINAL) != 0 || (mods & JMod.STATIC) != 0
				|| (mods & JMod.ABSTRACT) != 0 || (mods & JMod.NATIVE) != 0 || (mods & JMod.TRANSIENT) != 0 || (mods & JMod.VOLATILE) != 0))
			return false;
		return true;
	}

	/**
	 * Add the class level annotation, {@link ApiClass}
	 *
	 * @param o the ClassOutline
	 */
	protected void addClassAnnotation(final ClassOutline o) {
		JAnnotationUse apiClass = o.implClass.annotate(ApiClass.class);
		apiClass.param(VALUE, o.ref.name());
		apiClass.param(DESCRIPTION, new StringBuilder(o.ref.fullName())
				.append(DESCRIPTION_CLASS).toString());
	}

	/**
	 * Add method level annotation {@link ApiProperty}
	 *
	 * @param o the ClassOutline
	 * @param m the method to add annotation on
	 * @param default
	 * @param required
	 */
	protected void addMethodAnnotation(final JDefinedClass o, final JMethod m, final boolean required, final String defaultValue) {
		if (isValidMethod(m, GET)) {
			internalAddMethodAnnotation(o, m, GET, required, defaultValue);
		} else if (isValidMethod(m, IS)) {
			internalAddMethodAnnotation(o, m, IS, required, defaultValue);
		}
	}

	/**
	 * @param o
	 * @param m
	 * @param prefix
	 */
	private void internalAddMethodAnnotation(final JDefinedClass implClass, final JMethod m, final String prefix, final boolean required,
			final String defaultValue) {
		JAnnotationUse apiProperty = m.annotate(ApiProperty.class);
		String name = prepareNameFromMethod(m.name(), prefix);
		apiProperty.param(VALUE, name);
		String dataType = DataTypeDeterminationUtil.determineDataType(m.type());
		if (dataType != null) {
			apiProperty.param(DATA_TYPE, dataType);
		}
		if (required) {
			apiProperty.param("required", true);
		}
		if (null != defaultValue) {
			apiProperty.param("notes", defaultValue);
		}
	}


	private boolean isValidMethod(final JMethod m, final String prefix) {
		return m.name().startsWith(prefix) && m.name().length() > prefix.length();
	}

	/**
	 * Create the name for in a {@link ApiProperty#value()}
	 *
	 * @param getterName the name of a getter
	 * @param prefix
	 * @return the name without get and with first character set to lowerCase
	 */
	protected String prepareNameFromMethod(final String getterName, final String prefix) {
		String name = getterName.substring(prefix.length());
		StringBuilder b = new StringBuilder();
		b.append(Character.toLowerCase(name.charAt(0)));
		if (name.length() > 1) {
			b.append(name.substring(1));
		}
		return b.toString();
	}
}
